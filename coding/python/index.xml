<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coding - Othmane Rifki</title>
    <link>https://othrif.github.io/coding/python/index.xml</link>
    <description></description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Feb 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://othrif.github.io/coding/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Arrays</title>
      <link>https://othrif.github.io/coding/python/arrays.html</link>
      <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://othrif.github.io/coding/python/arrays.html</guid>
      <description>Definition Arrays in python are of list type that is dynamically resized. The tuple is similar but immutable.
Basic operations # Manipulate list A = list(range(10)) print(f&amp;#39;len() of A: {len(A)}&amp;#39;) A.append(5) print(f&amp;#39;append() to A: {A}&amp;#39;) A.remove(5) print(f&amp;#39;remove() first occurence from A: {A}&amp;#39;) A.insert(1, 999) print(f&amp;#39;insert() first occurence from A: {A}&amp;#39;) print(f&amp;#39;min() of A: {min(A)}&amp;#39;) print(f&amp;#39;max() of A: {max(A)}&amp;#39;) del A[1] print(f&amp;#39;del element with index i of A: {A}&amp;#39;) del A[:4] print(f&amp;#39;del a range of elements of A: {A}&amp;#39;) len() of A: 10 append() to A: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 5] remove() first occurence from A: [0, 1, 2, 3, 4, 6, 7, 8, 9, 5] insert() first occurence from A: [0, 999, 1, 2, 3, 4, 6, 7, 8, 9, 5] min() of A: 0 max() of A: 999 del element with index i of A: [0, 1, 2, 3, 4, 6, 7, 8, 9, 5] del a range of elements of A: [4, 6, 7, 8, 9, 5]  Copy 3 types:</description>
    </item>
    
    <item>
      <title>Primitive types</title>
      <link>https://othrif.github.io/coding/python/primitives.html</link>
      <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://othrif.github.io/coding/python/primitives.html</guid>
      <description>Definition Everything in Python is an object. Primitive types are built-in types such as: numerics (integers,etc.), sequences (lists&amp;hellip;), mappings (dict), classes, instances, and exceptions.
Key methods for numeric import math print(f&amp;#39;Absolutve value: {abs(-34.5)}&amp;#39;) print(f&amp;#39;Round up: {math.ceil(34.5)}&amp;#39;) print(f&amp;#39;Round down: {math.floor(34.5)}&amp;#39;) print(f&amp;#39;Max value: {max(34.5, 1000)}&amp;#39;) print(f&amp;#39;Power: {pow(34.5,2)} OR {34.5**2}&amp;#39;) print(f&amp;#39;Square root: {math.sqrt(34.5)}&amp;#39;) Absolutve value: 34.5 Round up: 35 Round down: 34 Max value: 1000 Power: 1190.25 OR 1190.25 Square root: 5.873670062235365  Interconvert numbers and strings str(42) &#39;42&#39;  int(&amp;#39;42&amp;#39;) 42  str(87.</description>
    </item>
    
    <item>
      <title>Queues</title>
      <link>https://othrif.github.io/coding/python/queues.html</link>
      <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://othrif.github.io/coding/python/queues.html</guid>
      <description>Deque Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.
Call: class collections.deque([iterable[, maxlen]])
if maxlen is specifified, deque is bounded to the specified maximum length.
Basic operations from collections import deque d = deque(&amp;#39;ghi&amp;#39;) for elem in d: print(elem.</description>
    </item>
    
    <item>
      <title>Strings</title>
      <link>https://othrif.github.io/coding/python/strings.html</link>
      <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://othrif.github.io/coding/python/strings.html</guid>
      <description>Definition String type is immutable. Need to allocate new strings when slicing or concatenating. Try to write values from the back, instead of front. Reduce space complexity by using the string itself instead of brute force O(n) solutions.
Basic operations t = &amp;#39;My first string&amp;#39; s = &amp;#39; first &amp;#39; print(f&amp;#39;in: {s in t}&amp;#39;) print(f&amp;#39;strip(): |{s}| -&amp;gt; |{s.strip()}|&amp;#39;) print(f&amp;#39;startswith(): {t.startswith(&amp;#34;M&amp;#34;)}&amp;#39;) print(f&amp;#39;endswith(): {t.endswith(&amp;#34;ing&amp;#34;)}&amp;#39;) print(f&amp;#39;STR.split(SEP): {t.split(&amp;#34; &amp;#34;)}&amp;#39;) print(f&amp;#39;SEP.join(LIST): {&amp;#34;/&amp;#34;.join([&amp;#34;hey&amp;#34;, &amp;#34;ho&amp;#34;, &amp;#34;O&amp;#34;])}&amp;#39;) print(f&amp;#39;STR.lower(): {t.</description>
    </item>
    
  </channel>
</rss>